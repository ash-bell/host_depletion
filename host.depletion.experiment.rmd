---
title: "host.depletion.experiment"
author: "Ashley Bell"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, echo = FALSE}
#only affects subsequent chunks
knitr::opts_knit$set(root.dir = '/Users/agb214/OneDrive - University of Exeter/PhD/Host depletion')
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
setwd("/Users/agb214/OneDrive - University of Exeter/PhD/Host depletion")
```

```{r libraries}
library(tidyverse)
library(ggpubr)
library(ggsignif)
library(car)
library(FSA)
library(RColorBrewer)
library(phyloseq)
library(decontam)
library(microViz)
library(cowplot)
library(picante)
library(patchwork)
library(ggordiplots)
library(corncob)
library(ggh4x)
library(gridExtra)

source("/Users/agb214/OneDrive - University of Exeter/PhD/R_files/pairwise.adonis2.R")

# Ashley preferences
set.seed(1234)
options(scipen=999) # no scientific notation for integers
`%!in%` = Negate(`%in%`) # not in function
```


### Project summary
Some introduction here
```{r data}
(data <- read_csv("data/host.depletion.data.clean.csv", show_col_types = FALSE) %>%
  mutate(Treatment.group = factor(Treatment.group, 
                                  levels = c("Standard DNA extraction",
                                             "CpG-methylated",
                                             "Hypotonic Lysis","Molysis",
                                             "PBS","Zymo","Positive Control",
                                             "Negative Control","NTC"),
                                  ordered = F)))

TG.clrs <- brewer.pal(n = 9, name = "Set1")
names(TG.clrs) <- levels(data$Treatment.group)
```

## What are the DNA extraction metrics
```{r DNA extraction}
data %>%
  group_by(Treatment.group) %>%
  summarise(Median.DNA.conc = median(DNA.concentration.ng.ul, na.rm = T),
            DNA.5.perc.quantile = quantile(DNA.concentration.ng.ul, 0.05, na.rm = T),
            DNA.95.perc.quantile = quantile(DNA.concentration.ng.ul, 0.95, na.rm = T),
            Median.260.280.ratio = median(`260.280.ratio`, na.rm = T),
            Median.260.230.ratio = median(`260.230.ratio`, na.rm = T)) %>%
  knitr::kable()
```

## Ratio 16S to 18S
```{r ratios}
data.filt <- data %>%
  filter(Treatment.group %!in% c("Negative Control", "NTC", "Positive Control")) %>%
  mutate(`18S.to.16S.ratio` = `18S.Cq.1` / `16S.Cq.1`)

### We can using a GLM with a Gamma distribution as data is slightly skewed to the right (indicative of a Gamma) but a Gaussian is probabaly okay based on the residuals of the QQ plot

lmer.ratio <- lme4::glmer(`18S.to.16S.ratio` ~ Treatment.group + (1 | Sampling.date), data = data.filt, na.action = na.omit, family = Gamma(link = "identity"))

# Statistically normal?
shapiro.test(resid(lmer.ratio))

# visually check. 
# General rule of thumb samples size over 30 = violation of the normality assumption should not cause major problems according to the central limit theorem. This only applies for data we expect normal. For example, coin tosses of survival analysis are never normal and a binomial distribution should be use. 
# For small sample sizes, normality tests have little power to reject the null hypothesis and  large sample sizes, significant results would be derived even in the case of a small deviation from normality, although this small deviation will not affect the results of a parametric test.  
qqnorm(resid(lmer.ratio))
qqline(resid(lmer.ratio))

# Heteroskedasticity (equal variance)
lmtest::bptest(resid(lmer.ratio) ~ fitted(lmer.ratio))



### According to Gavin Simpson on the GAMs course Day 1 1:58:20, residual deviance should be normal but for GLMs it rarely do. This is okay

# lmer.ratio <- glmer(`18S.to.16S.ratio` ~ Treatment.group + (1|Sampling.date), 
#                     data = data.filt)
# hist(resid(lmer.ratio))
# ks.test(resid(lmer.ratio), pnorm)
# shapiro.test(resid(lmer.ratio))
# lmtest::bptest(resid(lmer.ratio) ~ fitted(lmer.ratio))

# model <- lme4::glmer(`18S.to.16S.ratio` ~ Treatment.group*Sampling.date + (1|Sampling.date), family = Gamma(), data = data.filt)
# 
# transf <- data.filt$`18S.to.16S.ratio`
# 
# resam <- sample(transf, size = 5000, replace = T)
# hist(resam)
# 
# shapiro.test(resam)
# 
# m2 <- glm(transf ~ data.filt$Treatment.group * data.filt$Sampling.date, family = Gamma(), na.action = na.omit)
# summary(model)
# shapiro.test(resid(model))
# ks.test(resid(model), pnorm)
# lmtest::bptest(resid(model) ~ fitted(model))
# anova(m2, test = "F")

# tmp <- lme4::glmer(`18S.to.16S.ratio` ~ Treatment.group + (1|Sampling.date), family = inverse.gaussian(link = "1/mu^2"), data = data.filt)
# There are several distributions of data called families.
# Normal / Gaussian = symetrical bell shaped continuous data
# negative binomial = gaussian but with a chopped oof left tail. like number of worms capture has lots of 0s and peaks at 4, but some very succesful so ends at 24
# Binomial = 0 or 1s only, like flipping a coin or yes no.
# Poisson = whole numbers representing events. Count data or number of occurances of an event. bsically a shaper bellcurve / gaussian. Also can use quasipoisson when resid dev =/= res DFs
# exponetial = average time until event occurs - like time waiting in hospital - mostly 1s and 2s, some 45 but rare
 # gamma = very fat gauusian distribution. As mean increases, so does variance. like weight. Heavier weights =  more vairance in the possible weights, slight skew to the right
# Beta = between 0 and 1, models probability
# 
# # test for presence of autocorrelation in the residuals from 0 to 4. 2 means no autocorrelation. 
# # rule of thumb, between 1.8 and 2.2 = little autocorrelation
# durbinWatsonTest(residuals(tmp)) #1.853567
# 
# # Checking for Homoscedasticity (variance) of Residuals vs Fitted Values
# plot(fitted(tmp), residuals(tmp))
# lmtest::bptest(residuals(tmp) ~ fitted(tmp)) 

# test for normality of the residuals
# qqnorm(resid(tmp))
# qqline(resid(tmp))
# shapiro.test(resid(tmp)) # not normal 0.0000106

stat.table.ratio <- summary(lmerTest::lmer(`18S.to.16S.ratio` ~ Treatment.group +
                                             (1|Sampling.date), data = data.filt))$coefficients %>%
  as.data.frame() %>%
  rownames_to_column(var = "test") %>%
  mutate(p.adj = round(p.adjust(`Pr(>|t|)`, method = "BH"), digits = 3),
         Estimate = round(Estimate, digits = 3),
         pair1 = "Standard DNA extraction",
         pair2 = gsub("Treatment.group", "", test),
         sig.star = if_else(p.adj < 0.01, "***", 
                            if_else(p.adj < 0.01, "**", 
                                    if_else(p.adj < 0.05, "*",
                                            if_else(p.adj < 0.1, ".", ""))))) %>%
  filter(pair2 != "(Intercept)") %>%
  select(pair1, pair2, Estimate, `Std. Error`, p.adj, sig.star) %>%
  mutate(p.adj = if_else(p.adj < 0.001, "<0.001", as.character(p.adj)))

gridExtra::grid.table(stat.table.ratio)

(ratio.p <- data.filt %>%
    ggplot(aes(x = Treatment.group, y = `18S.to.16S.ratio`)) +
    geom_boxplot(aes(fill = Treatment.group)) +
    geom_dotplot(binaxis='y', stackdir='center', 
                 dotsize = 0.4, fill = "black") +
    geom_signif(data = stat.table.ratio,
                aes(xmin = pair1, xmax = pair2, annotations = sig.star, 
                y_position = c(1.3, 1.4, 1.5, 1.6, 1.7)), manual = T, size = 1) +
    scale_fill_manual(values = TG.clrs) +
    theme_bw() +
    ylab("Ratio of 18S to 16S rRNA Cq") +
    xlab("Treatment Group") +
    theme(legend.position = "none")
)
```


## Lets look at the 16S and 18S data here
```{r}
ps <- readRDS("data/phyloseq_taxa_tree.rds")

sample_data(ps) <- data %>%
  column_to_rownames(var = "phyloseq.sample.name") %>%
  mutate(Sampling.date = factor(Sampling.date, levels = c("09/09/2022","10/11/2022","01/12/2022")),
         Treatment.group = factor(Treatment.group, ordered = F))

sample_names(ps) <- sample_data(ps)$Sample
```

## We should probably root our phylotree for future functions
See https://github.com/joey711/phyloseq/issues/597
```{r}
pick_new_outgroup <- function(tree.unrooted){
    require("magrittr")
    require("data.table")
    require("ape") # ape::Ntip
    # tablify parts of tree that we need.
    treeDT <- 
      cbind(
        data.table(tree.unrooted$edge),
        data.table(length = tree.unrooted$edge.length)
      )[1:Ntip(tree.unrooted)] %>% 
      cbind(data.table(id = tree.unrooted$tip.label))
    # Take the longest terminal branch as outgroup
    new.outgroup <- treeDT[which.max(length)]$id
    return(new.outgroup)
  }

new.outgroup = pick_new_outgroup(phy_tree(ps))
rootedTree = ape::root(phy_tree(ps), outgroup=new.outgroup, resolve.root=TRUE)

phy_tree(ps) <- phy_tree(rootedTree)
# already done for 18S in preprocessing
```

## Positive controls
# What do my positive controls look like?
So we use ZymoBIOMICS Microbial Community DNA Standard (Zymo; D6305) as Pos1 -3 (contains DNA only) and ZymoBIOMICS Microbial Community Standard (Zymo; D6300) (contains cells) for Pos4.In Pos4 our extraction appears biased towards Lactobacillus / Limosilactobacillus and against Listeria which isn't present. DNA extraction problem?
```{r mock community comparison}
zymo.mock <- data.frame(sample = rep("Zymo", 8), 
                        rel.abundance = c(4.2,10.1,10.4,18.4,9.9,15.5,14.1,17.4),
                        Species = c("Pseudomonas aeruginosa","Escherichia coli","Salmonella enterica","Lactobacillus fermentum","Enterococcus faecalis","Staphylococcus aureus","Listeria monocytogenes","Bacillus subtilis"),
                        Genus = c("Pseudomonas","Escherichia","Salmonella","Lactobacillus","Enterococcus","Staphylococcus","Listeria","Bacillus"),
                        Genus2 = c("Pseudomonas","Escherichia-Shigella","Salmonella","Limosilactobacillus","Enterococcus","Staphylococcus","Listeria","Bacillus"))

zymo.mock <- zymo.mock[order(zymo.mock$Genus2), ]

clrs <- rep(brewer.pal(8, "Set1"), 3)
names(clrs) <- c(zymo.mock$Genus, zymo.mock$Species, zymo.mock$Genus2)

pos.plot <- ps %>%
  tax_fix() %>% 
  ps_filter(Treatment.group == "Positive Control") %>%
  tax_transform("compositional", rank = "Genus") %>%
  comp_barplot(tax_level = "Genus", tax_order = sort(zymo.mock$Genus2, decreasing = T), sample_order = c("Pos1","Pos2","Pos3","Pos4")) +
  scale_fill_manual(values = clrs) +
  guides(fill = guide_legend(reverse=T)) +
  ylab("Relative Abundance")

zymo.p <- ggplot(zymo.mock, aes(x = sample, y = rel.abundance/100, fill = Species)) +
  geom_bar(stat= "identity", colour="black") +
  scale_fill_brewer(palette = "Paired") +
  theme_minimal() +
  scale_fill_manual(values = clrs) +
  ylab("Relative Abundance") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.title.x = element_blank())
  
plot_grid(zymo.p, pos.plot, nrow = 1, labels = "AUTO", align = "v", rel_widths = c(1,1.75))
```

## Using the decontam frequency method, what contams are there?
So for the frequency method, you're meant to use the DNA concentration of samples before sequencing. This doesn't make sense becuase sequencing would equimolar pool your samples to get the same sequencing read depth. Anyways, we we equimolar pooled our samples to 10ng/uL. We could use either the DNA concetration before PCR (doesn't make much sense as it contains non-bacterial DNA) concentration after PCR clean-up but before equimolar pooling (Doesn't make sense because we increase/decrease each sample's concentration before sequencing). In addtion our negative samples have no DNA concentration as it was below the limits of detection (unsuprisng as we pratise sterile techniques). Phyloseq requires postive values, so I define NA or 0 DNA conc as half of the lowest DNA concentration found in all samples (MicroViz "halfmin" solution). I've also defined the sample concentration as the sample_sums(ps) as this is the number of reads I got back from sequencing and the most representative of each samples "DNA concentration" before sequencing.

To avoid messing up my data, this is now the "quant_reading" sample data column
```{r decontam frequencies}
sample_data(ps)$is.neg <- sample_data(ps)$Treatment.group %in% c("Negative Control", "NTC")

### frequency method
(halfmin <- min(data$DNA.concentration.ng.ul[data$DNA.concentration.ng.ul > 0], na.rm = T) / 2)

#sample_data(ps) <- sample_data(ps) %>%
#  data.frame() %>%
#  mutate(quant_reading = 
#           ifelse(is.na(DNA.concentration.ng.ul), halfmin,
#                  ifelse(DNA.concentration.ng.ul == 0, halfmin, #DNA.concentration.ng.ul)))

sample_data(ps) <- sample_data(ps) %>%
  data.frame() %>%
  mutate(quant_reading = sample_sums(ps))

# calculate contam
contamdf.freq <- isContaminant(ps, method="frequency", conc="quant_reading", threshold = 0.1)

# how many contam?
table(contamdf.freq$contaminant)

# 0.5 is too overzealous with detection as a lot of dots are outside of the expected line 0.1 default seems to be best
plot_frequency(ps, taxa_names(ps)[which(contamdf.freq$contaminant)[1:25]], conc="quant_reading") +
    xlab("Sample sums from each sample")
```

0.25 and 0.5 was too much, 0.1 seemed best for 16S

## What is the decontam prevalence method?
```{r decontam prevalence method}

contamdf.prev <- isContaminant(ps, method="prevalence", neg="is.neg", threshold=0.25)

# how many ASVs are contams
table(contamdf.prev$contaminant)

# plot identified contams by frequency and DNA
ps.pa <- transform_sample_counts(ps, function(abund) 1*(abund>0))
ps.pa.neg <- prune_samples(sample_data(ps.pa)$Treatment.group %in% c("Negative Control", "NTC"), ps.pa)
ps.pa.pos <- prune_samples(sample_data(ps.pa)$Treatment.group %!in% c("Negative Control", "NTC"), ps.pa)

# Make data.frame of prevalence in positive and negative samples
df.pa <- data.frame(pa.pos=taxa_sums(ps.pa.pos), pa.neg=taxa_sums(ps.pa.neg),
                      contaminant=contamdf.prev$contaminant)

# 16S 0.5 removes a lot of taxa in the plot_frequency plot that don't fit the trend. went for 0.25 instead
# 18S 0.1 and 0.25 look identical. 0.5 looks more likely contam patterns
ggplot(data=df.pa, aes(x=pa.neg, y=pa.pos, color=contaminant)) + geom_point() +
  xlab("Prevalence (Negative Controls)") + ylab("Prevalence (True Samples)")

plot_frequency(ps, taxa_names(ps)[sample(which(contamdf.prev$contaminant),25)], conc="quant_reading") +
    xlab("DNA Concentration before PCR")
```

## Are any of the combination methods better?
"combined" method seemed not to remove much 
"both" method removed almost nothing
so I went with the "either" method
```{r combination methods}
contamdf.comb <- isContaminant(ps, con = "quant_reading", method="either", neg="is.neg", threshold=c(0.1, 0.25))

table(contamdf.comb$contaminant) 

plot_frequency(ps, taxa_names(ps)[sample(which(contamdf.comb$contaminant),25)], conc="quant_reading") +
    xlab("DNA Concentration before PCR")
```

### Positive controls hopped to other samples?
Its work checking if the positive controls have hopped between samples - when I initially did my Positive control test, listeria was removed even though its a true ASV.

Its hard to tell if this captures anything. I think I won't bother with this
```{r}
pos.contamdf.prev <- isContaminant(ps, method="prevalence", neg=sample_data(ps)$Treatment.group == "Positive Control", threshold = 1)

table(pos.contamdf.prev$contaminant)

# plot identified contams by frequency and DNA
ps.pa <- transform_sample_counts(ps, function(abund) 1*(abund>0))
ps.pa.neg <- prune_samples(sample_data(ps.pa)$Treatment.group %in% c("Positive Control"), ps.pa)
ps.pa.pos <- prune_samples(sample_data(ps.pa)$Treatment.group %!in% c("Positive Control"), ps.pa)

# Make data.frame of prevalence in positive and negative samples
df.pa <- data.frame(pa.pos=taxa_sums(ps.pa.pos), pa.neg=taxa_sums(ps.pa.neg),
                      contaminant=contamdf.prev$contaminant)

# 0.5 removes a lot of taxa in the plot_frequency plot that don't fit the trend. went for 0.25 instead
ggplot(data=df.pa, aes(x=pa.neg, y=pa.pos, color=contaminant)) + geom_point() +
  xlab("Prevalence (Negative Controls)") + ylab("Prevalence (True Samples)")
```

### mito stats
```{r remove non-bacteria}
### Before pruning, check number of Chloroplast, mitochondria and other Euk reads
ps.trans <- ps %>%
  ps_filter(Treatment.group %!in% c("Positive Control", "Negative Control", "NTC")) %>%
  tax_fix(unknowns = c("Unknown Family"))

mito.stats <- tax_model(ps.trans, type = lmerTest::lmer, 
                        rank = "Family", taxa = "Mitochondria",
                        formula = "~ Treatment.group + (1 | Sampling.date)") %>%
  tax_models2stats(fun = broom.mixed::tidy) %>%
  tax_stats_get() %>%
  taxatree_stats_p_adjust(method = "BH", new_var = "p.adj") %>%
  mutate(pair1 = "Standard DNA extraction", 
         term = gsub("Treatment.group", "", term),
         sig.star = if_else(p.adj < 0.01, "***", 
                            if_else(p.adj < 0.01, "**", 
                                    if_else(p.adj < 0.05, "*",
                                            if_else(p.adj < 0.1, ".", 
                                                    if_else(p.adj > 0.1, "N.S.", "")))))) %>%
  filter(term %!in% c("sd__(Intercept)","sd__Observation")) %>%
  ungroup() %>%
  select(pair1, term, statistic, `std.error`, p.adj, sig.star) %>%
  rename(pair2 = term,
         estimate = statistic) %>%
  mutate_if(is.numeric, ~round(., 3))

grid.table(mito.stats)


# chloro.stats <- tax_model(ps.trans, type = corncob::bbdml, rank = "Order", taxa = "Chloroplast",
#             variables = "Treatment.group") %>%
#   tax_models2stats(param = "mu") %>%
#   tax_stats_get() %>%
#   taxatree_stats_p_adjust(method = "BH", grouping = "rank", new_var = "B.H. p adjusted")

mito.dat <- ps.trans %>%
  tax_transform(trans = "compositional", rank = "Family") %>%
  ps_get() %>%
  ps_otu2samdat("Mitochondria") %>%
  samdat_tbl() %>%
  select(Samples, Treatment.group, Mitochondria)

# chloro.dat <- ps.trans %>%
#   tax_transform(trans = "compositional", rank = "Order") %>%
#   ps_get() %>%
#   ps_otu2samdat("Chloroplast") %>%
#   samdat_tbl() %>%
#   select(Samples, Treatment.group, Chloroplast)

#full_join(chloro.dat, mito.dat, by = c("Samples", "Treatment.group")) %>%
mito.dat %>%
  #pivot_longer(cols = c("Chloroplast", "Mitochondria"), 
  pivot_longer(cols = Mitochondria, 
               names_to = "Taxa", values_to = "Relative_Abundance") %>%
  ggplot(aes(x = Treatment.group, y = Relative_Abundance)) +
  geom_boxplot(aes(fill = Treatment.group)) +
  scale_fill_manual(values = TG.clrs) +
  facet_wrap(~Taxa) +
  geom_signif(comparisons = list(c("Standard DNA extraction", "Zymo")),
              tip_length = 0, annotations = "N.S.", y_position = 0.035) +
  xlab("Treatment group") +
  ylab("Percentage relative abundance") +
  ylim(c(0, 0.04)) +
  theme_bw() +
    theme(legend.position="none", 
        axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))

```

## Remove non-bacterial sequences and contaminants
```{r}
### happy with that, prune contams and neg samples
ps.noncontam <- prune_taxa(!contamdf.comb$contaminant, ps)
ps.noncontam

ps.noncontam.noeuk <- subset_taxa(ps.noncontam, Family != "Mitochondria")
ps.noncontam.noeuk <- subset_taxa(ps.noncontam.noeuk, Order != "Chloroplast")
ps.noncontam.noeuk <- subset_taxa(ps.noncontam.noeuk, Kingdom != "Eukaryota")
ps.noncontam.noeuk

# Lets remove the positive samples as they aren't needed for further analyse
ps <- ps_filter(ps.noncontam.noeuk, Treatment.group %!in% c("Positive Control", "Negative Control", "NTC"))

hist(sample_sums(ps), breaks = length(sample_sums(ps)))
quantile(sample_sums(ps), probs = c(0, 0.01, 0.05, 0.95, 0.99, 1))
#saveRDS(ps, "data/ps_no_contam.rds")
```


### Alpha diversity
# Do my samples have different diversity metrics?
None of the alpha diversity metrics suggest any treatment group's alpha div means are different from other groups alpha div means
```{r}
ps <- readRDS("data/ps_no_contam.rds")
rarefy.ps <- rarefy_even_depth(ps, rngseed = 1234)

metadata <- sample_data(rarefy.ps) %>%
  data.frame() %>%
  select(Treatment.group, Sampling.date) %>%
  rownames_to_column(var = "Sample_ID")

alpha.div <- estimate_richness(rarefy.ps, measures = c("Chao1","Shannon")) %>%
  mutate(pd(samp = otu_table(rarefy.ps), tree = phy_tree(rarefy.ps), include.root = T), PD) %>%
  rownames_to_column(var = "Sample_ID") %>%
  left_join(metadata, by = "Sample_ID")

# Looking for differences between means, more than 2 groups. If parametric (normally distributed) and unpaired (samples are linked, i.e. same sample over time) then Welch's anova. If not parametric then  kruskal-wallis. I think doing different tests and comparing is wrong - so rather use the same test for all data.

# # Normal distribution? # p < 0.05 means not normal
# # Therefore cannot use parametric test
# shapiro.test(alpha.div$Shannon) # Not normal
# shapiro.test(alpha.div$Chao1) # Not normal just
# shapiro.test(alpha.div$PD) # Yes Normal
# 
# # Equal variance? # p < 0.05 means unequal variance
# leveneTest(Shannon ~ Treatment.group, data = alpha.div) # Not equal
# leveneTest(Chao1 ~ Treatment.group, data = alpha.div) # equal just
# leveneTest(PD ~ Treatment.group, data = alpha.div) # Equal
# 
# ## Kruskal-Wallis # NO sig diff overall
# kruskal.test(Shannon ~ Treatment.group, data = alpha.div) # No
# kruskal.test(Chao1 ~ Treatment.group, data = alpha.div) # No
# kruskal.test(PD ~ Treatment.group, data = alpha.div) # No
# 
# #DUNNS post-hoc test with BH correction # No groups sig diff
# dunnTest(alpha.div$Shannon,  alpha.div$Treatment.group, method="bh")$res %>%
#   filter(P.adj < 0.05) # No
# dunnTest(alpha.div$Chao1,  alpha.div$Treatment.group, method="bh")$res %>%
#   filter(P.adj < 0.05) # No
# dunnTest(alpha.div$PD,  alpha.div$Treatment.group, method="bh")$res %>%
#   filter(P.adj < 0.05) # No

# This only works if the phyloseq lib has never been loaded into this session due to conflicting source code libraries
# lmer.shannon <- glmer(Shannon ~ Treatment.group + (1|Sampling.date), family = stats::dbeta(), data = alpha.div)

# resid(lmer.shannon) %>% shapiro.test()
# hist(resid(lmer.shannon))

lmer.shannon <- summary(lmerTest::lmer(Shannon ~ Treatment.group + (1|Sampling.date), data = alpha.div))$coefficients %>%
  as.data.frame() %>%
  rownames_to_column(var = "test") %>%
  mutate(alpha.div.name = "Shannon")

lmer.Chao1 <- summary(lmerTest::lmer(Chao1 ~ Treatment.group + (1|Sampling.date), data = alpha.div))$coefficients %>%
  as.data.frame() %>%
  rownames_to_column(var = "test") %>%
  mutate(alpha.div.name = "Chao1")

lmer.PD <- summary(lmerTest::lmer(PD ~ Treatment.group + (1|Sampling.date), data = alpha.div))$coefficients %>%
  as.data.frame() %>%
  rownames_to_column(var = "test") %>%
  mutate(alpha.div.name = "PD")

lmer.alpha <- bind_rows(lmer.shannon, lmer.Chao1, lmer.PD) %>%
  mutate(p.adj = round(p.adjust(`Pr(>|t|)`, method = "BH"), digits = 3),
         Estimate = round(Estimate, digits = 3),
         pair1 = "Standard DNA extraction",
         pair2 = gsub("Treatment.group", "", test),
         sig.star = if_else(p.adj < 0.01, "***", 
                            if_else(p.adj < 0.01, "**", 
                                    if_else(p.adj < 0.05, "*",
                                            if_else(p.adj < 0.1, ".", 
                                                    if_else(p.adj > 0.1, "N.S.", "")))))) %>%
  filter(pair2 != "(Intercept)") %>%
  select(alpha.div.name, pair1, pair2, `Std. Error`, Estimate, p.adj, sig.star) %>%
  mutate(p.adj = if_else(p.adj < 0.001, "<0.001", as.character(p.adj))) %>%
  mutate(across(where(is.double), ~round(., digits = 2)))

gridExtra::grid.table(lmer.alpha)

# Lets plot it
alpha.div %>%
  pivot_longer(cols = c("Chao1", "Shannon", "PD"), names_to = "alpha.div.name", values_to = "alpha.div.value") %>%
  ggplot(aes(x = Treatment.group, y = alpha.div.value)) +
  geom_boxplot(aes(fill = Treatment.group)) +
  geom_signif(comparisons = list(c("Standard DNA extraction", "Zymo")),
              tip_length = 0, annotations = "N.S.") +
  facet_wrap(~alpha.div.name, scales = "free_y") +
  scale_fill_manual(values = TG.clrs) +
  theme_bw() +
  xlab("Treatment Group") +
  ylab("Alpha Diversity") +
  theme(legend.position="none", 
        axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))

lmer.shannon <- summary(lmerTest::lmer(Shannon ~ Sampling.date * Treatment.group + (1|Sampling.date), data = alpha.div))$coefficients %>%
  as.data.frame() %>%
  rownames_to_column(var = "test") %>%
  mutate(alpha.div.name = "Shannon")

lmer.Chao1 <- summary(lmerTest::lmer(Chao1 ~ Sampling.date * Treatment.group + (1|Sampling.date), data = alpha.div))$coefficients %>%
  as.data.frame() %>%
  rownames_to_column(var = "test") %>%
  mutate(alpha.div.name = "Chao1")

lmer.PD <- summary(lmerTest::lmer(PD ~ Sampling.date * Treatment.group + (1|Sampling.date), data = alpha.div))$coefficients %>%
  as.data.frame() %>%
  rownames_to_column(var = "test") %>%
  mutate(alpha.div.name = "PD")

lmer.alpha <- bind_rows(lmer.shannon, lmer.Chao1, lmer.PD) %>%
  mutate(p.adj = round(p.adjust(`Pr(>|t|)`, method = "BH"), digits = 3),
         Estimate = round(Estimate, digits = 3),
         pair1 = "Standard DNA extraction",
         pair2 = gsub("Treatment.group", "", test),
         sig.star = if_else(p.adj < 0.01, "***", 
                            if_else(p.adj < 0.01, "**", 
                                    if_else(p.adj < 0.05, "*",
                                            if_else(p.adj < 0.1, ".", 
                                                    if_else(p.adj > 0.1, "N.S.", "")))))) %>%
  filter(pair2 != "(Intercept)") %>%
  select(alpha.div.name, pair1, pair2, Estimate, p.adj, sig.star) %>%
  mutate(p.adj = if_else(p.adj < 0.001, "<0.001", as.character(p.adj))) #%>%
  #filter(p.adj < 0.05)

gridExtra::grid.table(lmer.alpha)

alpha.div %>%
  pivot_longer(cols = c("Chao1", "Shannon", "PD"), names_to = "alpha.div.name", values_to = "alpha.div.value") %>%
  ggplot(aes(x = Treatment.group, y = alpha.div.value)) +
  geom_boxplot(aes(fill = Treatment.group)) +
  geom_signif(comparisons = list(c("Standard DNA extraction", "Zymo")),
              tip_length = 0, annotations = "N.S.") +
  facet_grid2(Sampling.date~alpha.div.name, scales = "free_y", independent = "y") +
  scale_fill_manual(values = TG.clrs) +
  theme_bw() +
  xlab("Treatment Group") +
  ylab("Alpha Diversity") +
  theme(legend.position="none", 
        axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))

```

# This doesn't really tell us much
```{r}
otu_tab <- otu_table(ps) %>% as.data.frame()
#rcurve <- rarecurve(otu_tab, step = 1, sample = min(rowSums(otu_tab)), tidy = TRUE)
#saveRDS(rcurve, "data/rarefaction_curve.rds")
rcurve <- readRDS("data/rarefaction_curve.rds") %>% tibble()

metadata <- sample_data(ps) %>%
  data.frame() %>%
  select(Treatment.group, Sampling.date) %>%
  rownames_to_column(var = "Sample_ID")

# too much data so multiples of 10
one.to.max <- 1:max(rcurve$Sample)
multi.10 <- one.to.max[(one.to.max %% 100) == 0]

rcurve.filt <- rcurve %>%
  filter(Sample %in% multi.10) %>%
  dplyr:::rename(Sample_ID = Site,
                 Sample_Size = Sample) %>%
  left_join(metadata, by = "Sample_ID")

ggplot(rcurve.filt, aes(x = Sample_Size, y = Species/max(Species) * 100)) +
  geom_point(aes(colour = Treatment.group)) +
  facet_wrap(~Treatment.group) +
  scale_fill_manual(values = TG.clrs, aesthetics = c("fill", "colour")) +
  xlab("Sample size") +
  ylab("Percentage of ASVs within study") +
  theme_bw()

goods <- otu_tab %>%
  reframe(Sample_ID = rownames(.),
          singletons = rowSums(. == 1), 
          tot.abud = rowSums(.),
          inv.Goods.cov = singletons / tot.abud,
          Goods.cov = 1 - inv.Goods.cov,
          inv.Goods.cov.95 = (singletons / 0.05)) %>%
  left_join(metadata, by = "Sample_ID")

goods.median <- goods %>%
  group_by(Treatment.group) %>%
  summarise(median = round(median(Goods.cov), digits = 3))

ggplot(goods, aes(x = Treatment.group, y = Goods.cov)) +
  geom_boxplot(aes(fill = Treatment.group)) +
 # geom_text(data = goods.median,
#            aes(x = Treatment.group, y = median, label = median),
#            size = 5, vjust = -0.5) +
  scale_fill_manual(values = TG.clrs, aesthetics = c("fill", "colour")) +
  theme_bw()

#Goods coverage
```


### Lets look at beta diversity
Ashley note: Data needs to be compositional in some sort, don't use counts obviously. But why transform data to log2 or CLR? Rel abundant is what we want to know. Its because we are using a dissimilarity matrix which discriminate between samples by the most relatively abundant taxa not which taxa are the most variable". But if the most abundant taxa are driving changes in microbiome function and rare taxa have a limited role then this isn't important. Worth looking at CLR versus rel abund and see differences.
```{r}
# Final betadiversity figure here
ps <- readRDS("data/ps_no_contam.rds")

dates.clrs <- brewer.pal(n = 3, name = "Set2")
names(dates.clrs) <- levels(samdat_tbl(ps)$Sampling.date)

date.TG.clrs <- c(TG.clrs, dates.clrs)

bray.comp <- ps %>%
  tax_fix() %>%
  tax_transform(trans = "compositional", rank = "Genus") %>%
  dist_calc("bray") %>%
  ord_calc("NMDS") %>%
  ord_plot(color = "Treatment.group", size = 2, fill = "Treatment.group") +
  scale_color_manual(values = date.TG.clrs, aesthetics = c("fill", "colour")) +
  ggside::theme_ggside_void() +
  ggpubr::stat_chull(aes(fill = Treatment.group, color = Treatment.group), 
                     alpha = 0.1, geom = "polygon") +
  labs(fill = "Treatment Group", colour = "Treatment Group")

### stats
# get bray comps
comp.bray.dec <- ps %>%
  ps_filter(Sampling.date == "01/12/2022") %>%
  tax_fix() %>%
  tax_transform(trans = "compositional", rank = "Genus") %>%
  dist_calc("bray") %>%
  dist_permanova(seed = 1234, n_perms = 999, variables = "Treatment.group") %>%
  dist_bdisp(variables = "Treatment.group")

comp.bray.nov <- ps %>%
  ps_filter(Sampling.date == "10/11/2022") %>%
  tax_fix() %>%
  tax_transform(trans = "compositional", rank = "Genus") %>%
  dist_calc("bray") %>%
  dist_permanova(seed = 1234, n_perms = 999, variables = "Treatment.group") %>%
  dist_bdisp(variables = "Treatment.group")

comp.bray.sep <- ps %>%
  ps_filter(Sampling.date == "09/09/2022") %>%
  tax_fix() %>%
  tax_transform(trans = "compositional", rank = "Genus") %>%
  dist_calc("bray") %>%
  dist_permanova(seed = 1234, n_perms = 999, variables = "Treatment.group") %>%
  dist_bdisp(variables = "Treatment.group")

# get beta dispersions
comp.bray.sep.bdisp <- bdisp_get(comp.bray.sep)
comp.bray.sep.bdisp <- comp.bray.sep.bdisp$Treatment.group$tukeyHSD$group %>%
  data.frame() %>% select(p.adj) %>%
  rownames_to_column(var = "test") %>%
  separate_wider_delim(test, delim = "-", 
                       names = c("pair1","pair2"), 
                       too_many = "merge") %>%
  mutate(date = "09/09/2022", 
         sig = if_else(p.adj < 0.05, "Sig", "NS"))
  

comp.bray.nov.bdisp <- bdisp_get(comp.bray.nov)
comp.bray.nov.bdisp <- comp.bray.nov.bdisp$Treatment.group$tukeyHSD$group %>%
  data.frame() %>% select(p.adj) %>%
  rownames_to_column(var = "test") %>%
  separate_wider_delim(test, delim = "-", 
                       names = c("pair1","pair2"), 
                       too_many = "merge") %>%
  mutate(date = "10/11/2022", 
         sig = if_else(p.adj < 0.05, "Sig", "NS"))

comp.bray.dec.bdisp <- bdisp_get(comp.bray.dec)
comp.bray.dec.bdisp <- comp.bray.dec.bdisp$Treatment.group$tukeyHSD$group %>%
  data.frame() %>% select(p.adj) %>%
  rownames_to_column(var = "test") %>%
  separate_wider_delim(test, delim = "-", 
                       names = c("pair1","pair2"), 
                       too_many = "merge") %>%
  mutate(date = "01/12/2022",
          sig = if_else(p.adj < 0.05, "Sig", "NS"))

# concat
bdisp.all <- rbind(comp.bray.sep.bdisp, comp.bray.nov.bdisp, comp.bray.dec.bdisp) %>%
  mutate(pair1 = gsub("^CpG$", "CpG-methylated", pair1),
         pair2 = gsub("^methylated-", "", pair2)) %>%
  rename(p.adj.bdisp = p.adj) %>%
  rename(sig.bdisp = sig)

# not sure adonis2 is p.adjusted so adjust just in case
PA_tidy <- function(PA.output){
  tibble(PA.output) %>%
  slice_tail(n = -1) %>%
  unnest(cols = c(PA.output)) %>%
  na.exclude() %>%
  mutate(pairs = names(PA.output)[-1]) %>%
  separate(col = pairs, into = c("pair1", "pair2"), sep = "_vs_") %>%
  select(pair1, pair2, R2, `Pr(>F)`) %>%
  mutate(R2 = round(R2, digits = 2))
}

PA.comp.bray.sep <- pairwise.adonis2(dist_get(comp.bray.sep) ~ Treatment.group, data = data.frame(sample_data(ps_filter(ps, Sampling.date == "09/09/2022")))) %>%
  PA_tidy(.) %>% mutate(date = "09/09/2022")

PA.comp.bray.nov <- pairwise.adonis2(dist_get(comp.bray.nov) ~ Treatment.group, data = data.frame(sample_data(ps_filter(ps, Sampling.date == "10/11/2022")))) %>%
  PA_tidy(.) %>% mutate(date = "10/11/2022")

PA.comp.bray.dec <- pairwise.adonis2(dist_get(comp.bray.dec) ~ Treatment.group, data = data.frame(sample_data(ps_filter(ps, Sampling.date == "01/12/2022")))) %>%
  PA_tidy(.) %>% mutate(date = "01/12/2022")

PA.all <- rbind(PA.comp.bray.sep, PA.comp.bray.nov, PA.comp.bray.dec) %>%
  mutate(p.adj = p.adjust(`Pr(>F)`, method = "BH"),
         sig = if_else(p.adj < 0.05, "Sig", "NS")) %>%
  select(-`Pr(>F)`) %>%
  rename(p.adj.PA = p.adj) %>%
  rename(sig.PA = sig)

# stats table comes messed up with pair1 and pair2 or the other way, so need to fix
stats.table <- bdisp.all %>%
  left_join(PA.all, by = c("pair1","pair2","date")) %>%
  filter(is.na(R2)) %>%
  left_join(PA.all, by = join_by(pair1 == pair2, pair2 == pair1, "date")) %>%
  mutate(R2 = coalesce(R2.x, R2.y), 
         p.adj.PA = coalesce(p.adj.PA.x, p.adj.PA.y),
         sig.PA = coalesce(sig.PA.x, sig.PA.y), .keep = "unused")

stats.table.reverse <- bdisp.all %>%
  left_join(PA.all, by = c("pair1","pair2","date")) %>%
  filter(!is.na(R2))

stats.table.final <- rbind(stats.table, stats.table.reverse) %>%
  mutate(sig.PA = if_else(p.adj.PA <= 0.01, "***", 
                            if_else(p.adj.PA <= 0.01, "**", 
                                    if_else(p.adj.PA <= 0.05, "*",
                                            #if_else(p.adj.PA < 0.1, ".", 
                                                    if_else(p.adj.PA >= 0.05, "N.S.", "")))),
         sig.PA = if_else(p.adj.PA <= 0.05 & p.adj.bdisp <= 0.05, "bdisp_sig", sig.PA),
         date = as.Date(date, format = "%d/%m/%Y")) %>%
  mutate_if(is.numeric, ~round(., 3)) %>%
  #filter(sig.PA %!in% c("N.S.", "bdisp_sig", ".")) %>%
  #filter(pair1 == "Standard DNA extraction" | pair2 == "Standard DNA extraction") %>%
  arrange(date, pair1, pair2) %>%
  #select(-p.adj.bdisp, -sig.bdisp) %>%
  #select(pair1, pair2) %>%
  print(n = 100)

#grid.table(stats.table.final)

treat.order <- c("Standard DNA extraction", "CpG-methylated", "Hypotonic Lysis",
                 "Molysis", "PBS", "Zymo")

stats.table.final %>%
  mutate(pair1 = factor(pair1, levels = treat.order),
         pair2 = factor(pair2, levels = treat.order),
         #date = format(date, "%d-%b-%y")
         sig.PA = gsub("bdisp_sig","Group dispersion significant", sig.PA)
         ) %>%
dplyr::rename(`Pairwise adonis2 significance` = sig.PA) %>%
ggplot(aes(x = pair1, y = pair2, fill = `Pairwise adonis2 significance`)) +
  facet_wrap(~date) +
  geom_tile() +
  geom_text(aes(label = R2), color = "white", size = 4) +
  scale_fill_manual(values = c("steelblue","lightblue3","gold4")) +
  coord_fixed() +
  theme_bw() +
  xlab(element_blank()) +
  ylab(element_blank()) +
  theme(legend.position = "top", axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
  

```

```{r}
### Lets look at different transformations using RDA (as no need for dist matrix)
dist_plot <- function(ordination){
  ord_plot(data = ordination, color = "Treatment.group", size = 4, fill = "Sampling.date") +
  scale_color_manual(values = TG.clrs) +
  scale_fill_brewer(palette = "Set2") +
  ggside::geom_xsideboxplot(aes(fill = Sampling.date, y = Sampling.date), orientation = "y") +
  ggside::geom_ysideboxplot(aes(fill = Sampling.date, x = Sampling.date), orientation = "x") +
  ggside::scale_xsidey_discrete(labels = NULL) +
  ggside::scale_ysidex_discrete(labels = NULL) +
  stat_ellipse(aes(linetype = Sampling.date))
}

p1 <- ps %>%
  tax_fix() %>%
  tax_transform(trans = "compositional", rank = "Genus") %>%
  ord_calc(method = "PCA") %>%
  dist_plot(.)

p2 <- ps %>%
  tax_fix() %>%
  tax_transform(trans = "clr", rank = "Genus", zero_replace = "halfmin") %>%
  ord_calc(method = "PCA") %>%
  dist_plot(.)
  
p3 <- ps %>%
  tax_fix() %>%
  tax_transform(trans = "rclr", rank = "Genus") %>%
  ord_calc(method = "PCA") %>%
  dist_plot(.)

p4 <- ps %>%
  tax_fix() %>%
  tax_transform(trans = "log2", rank = "Genus", zero_replace = "halfmin") %>%
  ord_calc(method = "PCA") %>%
  dist_plot(.)

p5 <- ps %>%
  tax_fix() %>%
  tax_transform(trans = "compositional", rank = "Genus", zero_replace = "halfmin") %>%
  tax_transform(trans = "log2", chain = T) %>%
  ord_calc(method = "PCA") %>%
  dist_plot(.)

p6 <- ps %>%
  tax_fix() %>%
  tax_transform(trans = "compositional", rank = "Genus") %>%
  tax_transform(trans = "hellinger", chain = T) %>%
  ord_calc(method = "PCA") %>%
  dist_plot(.)

p1+p2+p3+p4+p5+p6+plot_layout(guides = "collect")

### I like rclr and compositional

sample_data(ps) %>%
  data.frame() %>%
  group_by(Treatment.group,Sampling.date) %>%
  summarise(n())

```

It looks like the sampling data has a large difference on the diversity found. We should therefore treat each date in a separate group. This is because each treatment is NOT represented equally at each date (for example, only PBS in 01/12/2022)

# We now need to calculate if any of the groups are significantly different, and if so, specifically which groups. Do this date by date and try using rclr and compositional.

```{r dist_matrices}
# Lets try a basic bray dissim matrix on compositional data
comp.bray.dec <- ps %>%
  ps_filter(Sampling.date == "01/12/2022") %>%
  tax_fix() %>%
  tax_transform(trans = "compositional", rank = "Genus") %>%
  dist_calc("bray") %>%
  dist_permanova(seed = 1234, n_perms = 999, variables = "Treatment.group") %>%
  dist_bdisp(variables = "Treatment.group")

# We need to know what the variance are within groups. If the variance within groups are significantly different compared to other groupings, PERMANOVA may be measuring this variance rather then the differences between centroids.

#what does this look like
plot(bdisp_get(comp.bray.dec)$Treatment.group$model)
boxplot(bdisp_get(comp.bray.dec)$Treatment.group$model)

# Tukey HSD to determine if sig diff between groups
bdisp_get(comp.bray.dec)$Treatment.group$tukeyHSD$group %>%
  data.frame() %>%
  filter(p.adj < 0.1)

# No sig diff between groups however I've noted that the molysis group appears to have different variances but is not statically supported
PA_tidy <- function(PA.output){
  tibble(PA.output) %>%
  slice_tail(n = -1) %>%
  unnest(cols = c(PA.output)) %>%
  na.exclude() %>%
  mutate(pairs = names(PA.output)[-1]) %>%
  separate(col = pairs, into = c("pair1", "pair2"), sep = "_vs_") %>%
  select(pair1, pair2, R2, `Pr(>F)`) %>%
  mutate(R2 = round(R2, digits = 2))
}

PA.comp.bray.dec <- pairwise.adonis2(dist_get(comp.bray.dec) ~ Treatment.group, data = data.frame(sample_data(ps_filter(ps, Sampling.date == "01/12/2022")))) %>%
  PA_tidy(.)

# so there is a sig diff between Molysis method and everything else
PA.comp.bray.dec %>%
  filter(`Pr(>F)` < 0.05) %>%
  filter(pair1 != "PBS", pair2 != "PBS")
```

So it looks like the molysis method has a sig diff beta diversity against the other groups, but I noticed molysis's variance was the most different. Lets compare the other dates and see if this is supported

```{r dist_matrices}
comp.bray.nov <- ps %>%
  ps_filter(Sampling.date == "10/11/2022") %>%
  tax_fix() %>%
  tax_transform(trans = "compositional", rank = "Genus") %>%
  dist_calc("bray") %>%
  dist_permanova(seed = 1234, n_perms = 999, variables = "Treatment.group") %>%
  dist_bdisp(variables = "Treatment.group")

comp.bray.sep <- ps %>%
  ps_filter(Sampling.date == "09/09/2022") %>%
  tax_fix() %>%
  tax_transform(trans = "compositional", rank = "Genus") %>%
  dist_calc("bray") %>%
  dist_permanova(seed = 1234, n_perms = 999, variables = "Treatment.group") %>%
  dist_bdisp(variables = "Treatment.group")

# Tukey HSD to determine if sig diff between groups
bdisp_get(comp.bray.nov)$Treatment.group$tukeyHSD$group %>%
  data.frame() %>%
  filter(p.adj < 0.05)
# So the molysis was sig diff variance between some groups, we need to be catious about interpreting results from this day

bdisp_get(comp.bray.sep)$Treatment.group$tukeyHSD$group %>%
  data.frame() %>%
  filter(p.adj < 0.05)
# So alot of samples were sig diff variance between some groups, we need to be catious about interpreting all results from this day

pairwise.adonis2(dist_get(comp.bray.nov) ~ Treatment.group, data = data.frame(sample_data(ps_filter(ps, Sampling.date == "10/11/2022")))) %>%
  PA_tidy(.) %>%
  filter(`Pr(>F)` < 0.05) # pairwise adonis found all groupings of molysis diff but we can't compare some groups due to betadispr results

pairwise.adonis2(dist_get(comp.bray.sep) ~ Treatment.group, data = data.frame(sample_data(ps_filter(ps, Sampling.date == "09/09/2022")))) %>%
  PA_tidy(.) %>%
  filter(`Pr(>F)` < 0.05) # nothing sig but alot of betadispr results was sig so not worth interpreting this too deeply
```

We've established molysis method in the Dec and some Nov batches to be problematic. Lets just look at the Dec batch and see different dissimularity matrixs and data transformations to see if this is still supported

```{r}
#########
####### I want to try wunifrac
#comp.wunif.dec <- ps %>%
#  ps_filter(Sampling.date == "01/12/2022") %>%
#  tax_fix() %>%
#  tax_transform(trans = "compositional", rank = "unique") %>%
#  dist_calc("wunifrac") %>%
#  dist_permanova(seed = 1234, n_perms = 999, variables = "Treatment.group") %>%
#  dist_bdisp(variables = "Treatment.group")

#saveRDS(comp.wunif.dec, "data/compositional.wunifrac.dec.rds")
comp.wunif.dec <- readRDS("data/compositional.wunifrac.dec.rds")

#comp.wunif.nov <- ps %>%
#  ps_filter(Sampling.date == "10/11/2022") %>%
#  tax_fix() %>%
#  tax_transform(trans = "compositional", rank = "unique") %>%
#  dist_calc("wunifrac") %>%
#  dist_permanova(seed = 1234, n_perms = 999, variables = "Treatment.group") %>%
#  dist_bdisp(variables = "Treatment.group")

#saveRDS(comp.wunif.nov, "data/compositional.wunifrac.nov.rds")
comp.wunif.nov <- readRDS("data/compositional.wunifrac.nov.rds")

# no problems
bdisp_get(comp.wunif.dec)$Treatment.group$tukeyHSD$group %>%
  data.frame() %>%
  filter(p.adj < 0.1)

# Problems with most molysis
bdisp_get(comp.wunif.nov)$Treatment.group$tukeyHSD$group %>%
  data.frame() %>%
  filter(p.adj < 0.1)

# Molysis still sig diff
pairwise.adonis2(dist_get(comp.wunif.dec) ~ Treatment.group, data = data.frame(sample_data(ps_filter(ps, Sampling.date == "01/12/2022")))) %>%
  PA_tidy(.) %>%
  filter(`Pr(>F)` < 0.05)

pairwise.adonis2(dist_get(comp.wunif.nov) ~ Treatment.group, data = data.frame(sample_data(ps_filter(ps, Sampling.date == "10/11/2022")))) %>%
  PA_tidy(.) %>%
  filter(`Pr(>F)` < 0.05)
```

```{r Aitchison}
#An Aitchison distance is the same as performing a PCA on the CLR data (see below) but also creates a distance matrix we can calculate dissimilarities from
# show aitchison is same as clr
ps %>%
  ps_filter(Sampling.date == "01/12/2022") %>%
  tax_fix() %>%
  tax_transform(trans = "clr", rank = "Genus") %>%
  ord_calc("PCA") %>%
  dist_plot()

ps %>%
  ps_filter(Sampling.date == "01/12/2022") %>%
  tax_fix() %>%
  tax_transform(trans = "identity", rank = "Genus") %>%
  dist_calc("aitchison") %>%
  ord_calc("PCoA") %>%
  dist_plot()

clr <- ps %>%
  ps_filter(Sampling.date == "01/12/2022") %>%
  tax_fix() %>%
  tax_transform(trans = "identity", rank = "Genus") %>%
  dist_calc("aitchison") %>%
  dist_permanova(seed = 1234, n_perms = 999, variables = "Treatment.group") %>%
  dist_bdisp(variables = "Treatment.group")

# no read difference between groups
bdisp_get(clr)$Treatment.group$tukeyHSD$group %>%
  data.frame() %>%
  filter(p.adj < 0.1) # up from 0.05 just to check

plot(bdisp_get(clr)$Treatment.group$model)
boxplot(bdisp_get(clr)$Treatment.group$model)

# Molysis and PBS method are some of the values that are significant
pairwise.adonis2(dist_get(clr) ~ Treatment.group, data = data.frame(sample_data(ps_filter(ps, Sampling.date == "01/12/2022")))) %>%
  PA_tidy(.) %>%
  filter(`Pr(>F)` < 0.05)
# so the CPG-methyalted groups appear more different this time
# other two methods used compositional date, this one aitchisons (clr)
# molysis still in 2/4 diffs
```

So the three different methods broadly say there is some doubt in the molysis method. What do they look like when plotted?
```{r}
dist_plot2 <- function(ordination){
  ord_plot(data = ordination, color = "Treatment.group", size = 2, fill = "Treatment.group") +
  scale_color_manual(values = TG.clrs) +
  scale_fill_manual(values = TG.clrs) +
  ggside::geom_xsideboxplot(aes(fill = Treatment.group, y = Treatment.group), orientation = "y") +
  ggside::geom_ysideboxplot(aes(fill = Treatment.group, x = Treatment.group), orientation = "x") +
  ggside::scale_xsidey_discrete(labels = NULL) +
  ggside::scale_ysidex_discrete(labels = NULL) +
  ggpubr::stat_stars(aes(color = Treatment.group)) +
  ggpubr::stat_chull(aes(fill = Treatment.group, 
                           color = Treatment.group), 
                     alpha = 0.1, 
                     geom = "polygon")
}

p1 <- clr %>%
  ord_calc("NMDS") %>%
  dist_plot2()

p2 <- comp.wunif.dec %>%
  ord_calc("NMDS") %>%
  dist_plot2()

p3 <- comp.bray.dec %>%
  ord_calc("NMDS") %>%
  dist_plot2()

p1+p2+p3+plot_layout(guides = "collect")

### IMHO the bray curtis or unifrac on comp data is best visually. Lets look at all the dates and the BC matric w/ compositional data at a genus level
```


```{r}
p1 <- comp.bray.sep %>%
  ord_calc("NMDS") %>%
  dist_plot2()

p2 <- comp.bray.nov %>%
  ord_calc("NMDS") %>%
  dist_plot2()

p3 <- comp.bray.dec %>%
  ord_calc("NMDS") %>%
  dist_plot2()

p4 <- comp.wunif.nov %>%
  ord_calc("NMDS") %>%
  dist_plot2()

p5 <- comp.wunif.dec %>%
  ord_calc("NMDS") %>%
  dist_plot2()

# p1 looks terrible and suffers from a lack of samples with alot of betadispr problems p2 and p3 are better to use maybe just keep p1 as the pilot

p1+p2+p3+p4+p5+plot_layout(guides = "collect")
```
To summaries we determined that date plays a large difference in beta diversity and we should look at each date differently. Using a BC/aitchison/wunifrac matrix all suggest that molysis method has a different beta diversity, but the novemeber has some difficult interpreting the results as the betapermdis is sig. The September date has too little samples to be able to draw conclusions. The BC matric on comp data has less sig betapermdis (good) and more sig pairwise permanova (good) than the wunifrac but its marginal. Its also better visualises the date using a NMDS (also marginal). We should therefore use the BC matric on comp data with NMDS sep by Nov and Dec, (maybe remove sep data if justifiable)

```{r beta-diversity plots}
dist_plot3 <- function(ordination){
  ord_plot(data = ordination, color = "Treatment.group", size = 2, fill = "Treatment.group") +
  scale_color_manual(values = TG.clrs, aesthetics = c("fill", "colour")) +
  ggside::geom_xsideboxplot(aes(fill = Treatment.group, y = Treatment.group), orientation = "y") +
  ggside::geom_ysideboxplot(aes(fill = Treatment.group, x = Treatment.group), orientation = "x") +
  ggside::scale_xsidey_discrete(labels = NULL) +
  ggside::scale_ysidex_discrete(labels = NULL) +
  ggside::theme_ggside_void() +
  ggpubr::stat_chull(aes(fill = Treatment.group, color = Treatment.group), 
                     alpha = 0.1, geom = "polygon")
}

p1 <- comp.bray.sep %>%
  ord_calc("NMDS") %>%
  dist_plot3()

p2 <- comp.bray.nov %>%
  ord_calc("NMDS") %>%
  dist_plot3()

p3 <- comp.bray.dec %>%
  ord_calc("NMDS") %>%
  dist_plot3()

p1 + p2 + p3 + patchwork::plot_layout(guides = "collect") & theme(legend.position = 'bottom')

bray.comp <- ps %>%
  tax_fix() %>%
  tax_transform(trans = "compositional", rank = "Genus") %>%
  dist_calc("bray") %>%
  ord_calc("NMDS") %>%
  ord_plot(color = "Treatment.group", size = 2, fill = "Treatment.group") +
  scale_color_manual(values = date.TG.clrs, aesthetics = c("fill", "colour")) +
  #ggside::geom_xsideboxplot(aes(fill = Sampling.date, y = Sampling.date), orientation = "y") +
  #ggside::geom_ysideboxplot(aes(fill = Sampling.date, x = Sampling.date), orientation = "x") +
  #ggside::scale_xsidey_discrete(labels = NULL) +
  #ggside::scale_ysidex_discrete(labels = NULL) +
  ggside::theme_ggside_void() +
  ggpubr::stat_chull(aes(fill = Treatment.group, color = Treatment.group), 
                     alpha = 0.1, geom = "polygon")

bray.comp <- ps %>%
  tax_fix() %>%
  tax_transform(trans = "compositional", rank = "Genus") %>%
  dist_calc("bray") %>%
  dist_get() %>%
  as.matrix() %>%
  reshape2::melt() %>%
  filter(Var1 != Var2) %>%
  left_join(samdat_tbl(ps), by = join_by(Var1 == Samples)) %>%
  group_by(Sampling.date) %>%
  filter(Var2 %in% Var1) %>%
  ungroup() %>%
  filter(grepl("^L", Var1)) %>%
  select(Var2, value) %>%
  left_join(samdat_tbl(ps), by = join_by(Var2 == Samples)) %>%
  select(Treatment.group, value, Sampling.date) %>%
  mutate(composition = "bray")

aitchison.comp <- ps %>%
  tax_fix() %>%
  tax_transform(trans = "identity", rank = "Genus") %>%
  dist_calc("aitchison") %>%
  dist_get() %>%
  as.matrix() %>%
  reshape2::melt() %>%
  filter(Var1 != Var2) %>%
  left_join(samdat_tbl(ps), by = join_by(Var1 == Samples)) %>%
  group_by(Sampling.date) %>%
  filter(Var2 %in% Var1) %>%
  ungroup() %>%
  filter(grepl("^L", Var1)) %>%
  select(Var2, value) %>%
  left_join(samdat_tbl(ps), by = join_by(Var2 == Samples)) %>%
  select(Treatment.group, value, Sampling.date) %>%
  mutate(composition = "aitchison")

# wunifrac.comp <- ps %>%
#   tax_fix() %>%
#   tax_transform(trans = "identity", rank = "unique") %>%
#   dist_calc("gunifrac", gunifrac_alpha = 0.5) %>%
#   dist_get() %>%
#   as.matrix() %>%
#   reshape2::melt() %>%
#   filter(Var1 != Var2) %>%
#   left_join(samdat_tbl(ps), by = join_by(Var1 == Samples)) %>%
#   group_by(Sampling.date) %>%
#   filter(Var2 %in% Var1) %>%
#   ungroup() %>%
#   filter(grepl("^L", Var1)) %>%
#   select(Var2, value) %>%
#   left_join(samdat_tbl(ps), by = join_by(Var2 == Samples)) %>%
#   select(Treatment.group, value, Sampling.date) %>%
#   mutate(composition = "wunifrac")

#saveRDS(wunifrac.comp, "data/wunifrac.comp.rds")
wunifrac.comp <- readRDS("data/wunifrac.comp.rds") %>% 
  rename(composition = compostion)

bin.jacc.comp <- ps %>%
  tax_fix() %>%
  tax_transform(trans = "binary", rank = "Genus") %>%
  dist_calc("jaccard", binary = T) %>%
  dist_get() %>%
  as.matrix() %>%
  reshape2::melt() %>%
  filter(Var1 != Var2) %>%
  left_join(samdat_tbl(ps), by = join_by(Var1 == Samples)) %>%
  group_by(Sampling.date) %>%
  filter(Var2 %in% Var1) %>%
  ungroup() %>%
  filter(grepl("^L", Var1)) %>%
  select(Var2, value) %>%
  left_join(samdat_tbl(ps), by = join_by(Var2 == Samples)) %>%
  select(Treatment.group, value, Sampling.date) %>%
  mutate(composition = "Binary Jaccard")

stats.table.BD <- data.frame()

lmer_test <- function(dataset) {
  lmerTest::lmer(value ~ Treatment.group + (1|Sampling.date), data = dataset) %>%
  broom.mixed::tidy() %>%
  filter(effect == "fixed") %>%
  mutate(composition = dataset$composition[1])
}

for (i in list(bray.comp, aitchison.comp, bin.jacc.comp, wunifrac.comp)){
  stats.table.BD <- bind_rows(stats.table.BD, lmer_test(i))
}

stats.table.BD.filt <- stats.table.BD %>%
  mutate(p.adj = p.adjust(p.value, "BH"),
         term = str_replace(term, "Treatment.group", ""),
         term2 = "Standard DNA extraction",
         sig.stat = if_else(p.adj < 0.01, "***", 
                            if_else(p.adj < 0.01, "**", 
                                    if_else(p.adj < 0.05, "*",
                                                    if_else(p.adj > 0.05, "N.S.", ""))))) %>%
  filter(p.adj < 0.05, term != "(Intercept)") %>%
  mutate_if(is.numeric, ~round(., 3))

# with(bin.jacc.comp, shapiro.test(value))
# 
# # Normal distribution? # p < 0.05 means not normal
# # Therefore cannot use parametric test
# with(bray.comp, shapiro.test(value)) # Not normal
# with(aitchison.comp, shapiro.test(value)) # Not normal
# with(wunifrac.comp, shapiro.test(value)) # Not normal
# with(bin.jacc.comp, shapiro.test(value)) # Not normal
# 
# # Equal variance? # p < 0.05 means unequal variance
# with(bray.comp, leveneTest(value ~ Treatment.group)) # Not normal
# with(aitchison.comp, leveneTest(value ~ Treatment.group)) # normal
# with(wunifrac.comp, leveneTest(value ~ Treatment.group)) # Not normal
# with(bin.jacc.comp, leveneTest(value ~ Treatment.group)) # Not normal
# 
# ## Kruskal-Wallis # sig diff overall
# kruskal.test(value ~ Treatment.group, data = bray.comp)
# 
# #DUNNS post-hoc test with BH correction
# stats_table <- rbind(
# with(bray.comp, dunnTest(value, Treatment.group, method="bh"))$res %>%
#   separate_wider_delim(Comparison, " - ", names = c("pair1", "pair2")) %>%
#   mutate(composition = "bray"),
# 
# with(aitchison.comp, dunnTest(value, Treatment.group, method="bh"))$res %>%
#   separate_wider_delim(Comparison, " - ", names = c("pair1", "pair2")) %>%
#   mutate(composition = "aitchison"),
# 
# with(wunifrac.comp, dunnTest(value, Treatment.group, method="bh"))$res %>%
#   separate_wider_delim(Comparison, " - ", names = c("pair1", "pair2")) %>%
#   mutate(composition = "wunifrac"),
# 
# with(bin.jacc.comp, dunnTest(value, Treatment.group, method="bh"))$res %>%
#   separate_wider_delim(Comparison, " - ", names = c("pair1", "pair2")) %>%
#   mutate(composition = "Binary Jaccard")
# ) %>%
#   filter(pair1 == "Standard DNA extraction" | pair2 == "Standard DNA extraction") %>%
#   mutate(P.adj = p.adjust(P.unadj, method = "BH"),
#          sig.star = if_else(P.adj < 0.01, "***", 
#                             if_else(P.adj < 0.01, "**", 
#                                     if_else(P.adj < 0.05, "*", "")))) %>%
#   filter(P.adj < 0.001)
# 
# stats_table

comps <- rbind(bray.comp, aitchison.comp, bin.jacc.comp, wunifrac.comp)

ggplot(comps, aes(Treatment.group, value)) +
  geom_boxplot(aes(fill = Treatment.group)) +
  geom_signif(data = stats.table.BD.filt,
              aes(xmin = term2, xmax = term, annotations = sig.stat,
                  y_position = c(1, 1.1, 1.2, 95, 1, 1.1, 0.75)), manual = T) +
  facet_wrap(~composition, scales = "free_y") +
  scale_fill_manual(values = TG.clrs) +
  theme_bw() +
  xlab("Treatment Group") +
  ylab("Distance from standard extraction samples") +
  theme(legend.position="none", 
        axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))


ggplot(comps, aes(Treatment.group, value)) +
  geom_boxplot(aes(fill = Treatment.group)) +
  #geom_jitter(width = 0.1) +
  geom_signif(comparisons = list(c("Standard DNA extraction", "CpG-methylated"),
                                 c("Standard DNA extraction", "Hypotonic Lysis"),
                                 c("Standard DNA extraction", "Molysis"),
                                 c("Standard DNA extraction", "PBS"),
                                 c("Standard DNA extraction", "Zymo")),
              step_increase = 0.1, 
              map_signif_level = c("***"=0.001, "**"=0.01, "*"=0.05)) +
  facet_wrap(~composition, scales = "free_y") +
  scale_fill_manual(values = TG.clrs) +
  theme_bw() +
  xlab("Treatment Group") +
  ylab("Distance from standard extraction samples") +
  theme(legend.position="none", 
        axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))

comp.bray.sep.bdisp <- bdisp_get(comp.bray.sep)
comp.bray.sep.bdisp <- comp.bray.sep.bdisp$Treatment.group$tukeyHSD$group %>%
  data.frame() %>% select(p.adj) %>%
  rownames_to_column(var = "test") %>%
  separate_wider_delim(test, delim = "-", 
                       names = c("pair1","pair2"), 
                       too_many = "merge") %>%
  mutate(date = "09/09/2022", 
         sig = if_else(p.adj < 0.05, "Sig", "NS"))
  

comp.bray.nov.bdisp <- bdisp_get(comp.bray.nov)
comp.bray.nov.bdisp <- comp.bray.nov.bdisp$Treatment.group$tukeyHSD$group %>%
  data.frame() %>% select(p.adj) %>%
  rownames_to_column(var = "test") %>%
  separate_wider_delim(test, delim = "-", 
                       names = c("pair1","pair2"), 
                       too_many = "merge") %>%
  mutate(date = "10/11/2022", 
         sig = if_else(p.adj < 0.05, "Sig", "NS"))

comp.bray.dec.bdisp <- bdisp_get(comp.bray.dec)
comp.bray.dec.bdisp <- comp.bray.dec.bdisp$Treatment.group$tukeyHSD$group %>%
  data.frame() %>% select(p.adj) %>%
  rownames_to_column(var = "test") %>%
  separate_wider_delim(test, delim = "-", 
                       names = c("pair1","pair2"), 
                       too_many = "merge") %>%
  mutate(date = "01/12/2022",
          sig = if_else(p.adj < 0.05, "Sig", "NS"))

bdisp.all <- rbind(comp.bray.sep.bdisp, comp.bray.nov.bdisp, comp.bray.dec.bdisp) %>%
  mutate(pair1 = gsub("^CpG$", "CpG-methylated", pair1),
         pair2 = gsub("^methylated-", "", pair2)) %>%
  rename(p.adj.bdisp = p.adj) %>%
  rename(sig.bdisp = sig)

# not sure adonis2 is p.adjusted so adjust just in case
PA.comp.bray.sep <- pairwise.adonis2(dist_get(comp.bray.sep) ~ Treatment.group, data = data.frame(sample_data(ps_filter(ps, Sampling.date == "09/09/2022")))) %>%
  PA_tidy(.) %>% mutate(date = "09/09/2022")

PA.comp.bray.nov <- pairwise.adonis2(dist_get(comp.bray.nov) ~ Treatment.group, data = data.frame(sample_data(ps_filter(ps, Sampling.date == "10/11/2022")))) %>%
  PA_tidy(.) %>% mutate(date = "10/11/2022")

PA.comp.bray.dec <- pairwise.adonis2(dist_get(comp.bray.dec) ~ Treatment.group, data = data.frame(sample_data(ps_filter(ps, Sampling.date == "01/12/2022")))) %>%
  PA_tidy(.) %>% mutate(date = "01/12/2022")

PA.all <- rbind(PA.comp.bray.sep, PA.comp.bray.nov, PA.comp.bray.dec) %>%
  mutate(p.adj = p.adjust(`Pr(>F)`, method = "BH"),
         sig = if_else(p.adj < 0.05, "Sig", "NS")) %>%
  select(-`Pr(>F)`) %>%
  rename(p.adj.PA = p.adj) %>%
  rename(sig.PA = sig)

stats.table <- bdisp.all %>%
  left_join(PA.all, by = c("pair1","pair2","date")) %>%
  filter(is.na(R2)) %>%
  left_join(PA.all, by = join_by(pair1 == pair2, pair2 == pair1, "date")) %>%
  mutate(R2 = coalesce(R2.x, R2.y), 
         p.adj.PA = coalesce(p.adj.PA.x, p.adj.PA.y),
         sig.PA = coalesce(sig.PA.x, sig.PA.y), .keep = "unused")

stats.table.reverse <- bdisp.all %>%
  left_join(PA.all, by = c("pair1","pair2","date")) %>%
  filter(!is.na(R2))

stats.table.final <- rbind(stats.table, stats.table.reverse) %>%
  mutate(sig.PA = if_else(p.adj.bdisp < 0.05, "bdisp_sig", sig.PA)) %>%
  print(n = 50)

write.csv(stats.table.final, "data/beta_diversity_stats_table.csv")
```

# Specifically which taxa are different?
```{r}
# Across all sampling.dates
diff.abund <- ps %>%
  tax_fix() %>%
  tax_filter(min_total_abundance = 0.01, tax_level = "Order") %>%
  tax_transform(trans = "identity", rank = "Order") %>%
  tax_prepend_ranks() %>%
  taxatree_models(rank = NULL, formula = "~ Treatment.group + (1 | Sampling.date)", 
                  type = lmerTest::lmer) %>%
  taxatree_models2stats(fun = broom.mixed::tidy) %>%
  taxatree_stats_p_adjust(method = "BH", grouping = "rank", new_var = "p.adj")

tax.trees <- diff.abund %>%
taxatree_plots(sig_stat = "p.adj",
                colour_trans = "identity",
                palette = "Blue-Red 3", 
                l2 = 90,
                sig_shape = "circle filled", 
                sig_size = 4,
                sig_stroke = 3,
                sig_colour = "white",
                sig_threshold = 0.05,
                layout = "fr",
                layout_seed = 1234,
                var_renamer = function(x) str_replace_all(x, "Treatment.group", ""),
                )
  
rename.legend <- labs(colour = "Estimate (relative abundance)", 
       fill = "Estimate (relative abundance)", 
       edge_colour ="Estimate (relative abundance)",
       size = "Prevalence",
       edge_width = "Prevalence")

plots <- list(
  p1 <- (tax.trees$`Treatment.groupCpG-methylated` + rename.legend),
  p2 <- (tax.trees$`Treatment.groupHypotonic Lysis` + rename.legend),
  p3 <- (tax.trees$Treatment.groupMolysis + rename.legend),
  p4 <- (tax.trees$Treatment.groupPBS + rename.legend),
  p5 <- (tax.trees$Treatment.groupZymo + rename.legend)
)

tax.trees.all <- patchwork::wrap_plots(plots, guides = "collect")

key <- diff.abund %>%
  taxatree_plotkey(
    taxon_renamer = function(x) stringr::str_remove(x, "[PCO]: "),
    rank == "Phylum" | rank == "Class" | rank == "Order",
    !grepl("Kingdom", taxon),
    layout = "fr",
    layout_seed = 1234
    ) +
  scale_x_continuous(expand = expansion(mult = 0.2))

diff.abund.all.dates <- wrap_plots(key, tax.trees.all, widths = c(1:2))

dev.off()
diff.abund %>%
  taxatree_stats_get() %>%
  #filter(`B.H. p adjusted` < 0.05) %>%
  mutate_if(is.numeric, ~round(., 3)) %>%
  mutate(p.adj = if_else(p.adj < 0.001, "<0.001", as.character(p.adj))) %>%
    gridExtra::grid.table(.)
```

```{r perc trout metagenomic}
trout <- read_table("data/trout_mapping_stats.tsv", show_col_types = F) %>%
  filter(file != "file") %>%
  mutate(across(c(4:8), ~as.numeric(str_replace_all(., ",","")))) %>%
  unique() %>%
  mutate(file = gsub(".*META_", "", file),
         file = gsub("_S3.._trout", "", file),
         file = gsub(".fq.gz", "", file)) %>%
  separate(file, c("sample","type")) %>%
  select(sample, type, sum_len) %>%
  group_by(sample) %>%
  mutate(as_perc = sum_len / sum(sum_len) * 100) %>%
  ungroup()

trout.boxplot <- trout %>%
  filter(type == "unmapped") %>%
  filter(sample != "BF3") %>%
  separate_wider_position(sample, c(Treatment.group = 1, replicate = 1, time = 2), too_few = "align_start") %>% 
  mutate(Treatment.group = if_else(
    Treatment.group == "L", "Standard DNA extraction", 
        if_else(Treatment.group == "N", "CpG-methylated",
            if_else(Treatment.group == "Z","Zymo", NA))),
    Treatment.group = factor(Treatment.group, levels = c("Standard DNA extraction", "CpG-methylated", "Zymo")))

## lmer # sig diff overall
lmer.trout <- summary(lmerTest::lmer(as_perc ~ Treatment.group + (1|time), data = trout.boxplot))

stat.table <- summary(lmerTest::lmer(as_perc ~ Treatment.group + (1|time), 
                                     data = trout.boxplot))$coefficients %>%
  as.data.frame() %>%
  rownames_to_column(var = "test") %>%
  mutate(p.adj = round(p.adjust(`Pr(>|t|)`, method = "BH"), digits = 3)) %>%
  mutate(pair1 = "Standard DNA extraction",
         pair2 = gsub("Treatment.group", "", test),
         sig.star = if_else(p.adj < 0.01, "***", 
                            if_else(p.adj < 0.01, "**", 
                                    if_else(p.adj < 0.05, "*",
                                            if_else(p.adj < 0.1, ".", ""))))) %>%
  filter(pair2 != "(Intercept)") %>%
  select(pair1, pair2, Estimate, `Std. Error`, p.adj, sig.star) %>%
  mutate(across(where(is.double), ~round(., 2)))

gridExtra::grid.table(stat.table)
  
trout.median <- trout.boxplot %>%
  group_by(Treatment.group) %>%
  summarise(median = round(median(as_perc), digits = 1))
  
ggplot(trout.boxplot,
       aes(x = Treatment.group, y = as_perc)) +
  geom_boxplot(aes(fill = Treatment.group)) +
  geom_text(data = trout.median,
            aes(x = Treatment.group, y = median, label = median),
            size = 5, vjust = -0.5) +
  geom_point(size = 3) +
  geom_signif(data = filter(stat.table, p.adj <= 0.05), 
              aes(xmin = pair1, xmax = pair2, annotations = sig.star, 
                  y_position = 29), manual = T, size = 1) +
  scale_fill_manual(values = TG.clrs) +
  xlab("Treatment Group") +
  ylab("Nuclotides identified as microbial (%)") +
  theme_bw()
```

```{r}
# What is the proportion identified bacterial / archaeal reads

taxa.files <- Sys.glob("data/*_bac_arc.tsv")


taxa.data <- map_dfr(taxa.files,
                     ~read_tsv(.x, col_names = "lineage", 
                               id = "path") %>%
                       mutate(path = str_remove(path, "data/") %>%
                                     str_remove("_S..._bac_arc.tsv"))) %>% 
  rename(Sample = path) %>%
  separate(lineage, sep = ";", c("K","P","C","O","F","G","S")) %>%
  filter(Sample != "BF3") %>%
  separate_wider_position(Sample, c(Treatment.group = 1, replicate = 1, time = 2), too_few = "align_start") %>% 
  mutate(Treatment.group = if_else(
    Treatment.group == "L", "Standard DNA extraction", 
        if_else(Treatment.group == "N", "CpG-methylated",
            if_else(Treatment.group == "Z","Zymo", NA))),
    Treatment.group = factor(Treatment.group, levels = c("Standard DNA extraction", "CpG-methylated", "Zymo")))

Genus <- taxa.data %>%
  select(-S) %>%
  group_by(across(everything())) %>%
  summarise(n = n(), .groups = "drop")

Phylum <- taxa.data %>%
  select(Treatment.group, replicate, time, P) %>%
  group_by(across(everything())) %>%
  summarise(n = n(), .groups = "drop_last") %>%
  mutate(total = sum(n),
         n = n/total) %>%
  filter(n > 0.01) %>%
  filter(!str_detect(P, "unclassified"))

Phylum %>%
  ggplot(aes(x=Treatment.group, y=n*100, fill = Treatment.group)) +
  geom_boxplot() +
  facet_wrap(~P, scales = "free_y") + 
  geom_point(size = 3) +
  scale_fill_manual(values = TG.clrs) +
  xlab("Treatment Group") +
  ylab("Phylum relative abundance") +
  theme_bw()


classifications <- tibble(data = c(
  "826,11143_HD_META_BF3_S396_taxonomy_clean.tsv,295",
  "24180214,11143_HD_META_L1T3_S382_taxonomy_clean.tsv,3385224",
  "23818436,11143_HD_META_L2T1_S381_taxonomy_clean.tsv,3704925",
  "24171640,11143_HD_META_L6T3_S383_taxonomy_clean.tsv,3800283",
  "20755429,11143_HD_META_L7T2_S384_taxonomy_clean.tsv,3228258",
  "24832516,11143_HD_META_L8T2_S385_taxonomy_clean.tsv,3914006",
  "26507787,11143_HD_META_N2T1_S391_taxonomy_clean.tsv,4016418",
  "21066068,11143_HD_META_N2T3_S392_taxonomy_clean.tsv,3240039",
  "25072552,11143_HD_META_N4T2_S394_taxonomy_clean.tsv,3932612",
  "17646791,11143_HD_META_N4T3_S393_taxonomy_clean.tsv,2668964",
  "19049432,11143_HD_META_N5T2_S395_taxonomy_clean.tsv,2947698",
  "23914788,11143_HD_META_Z2T2_S389_taxonomy_clean.tsv,3640510",
  "24458294,11143_HD_META_Z2T3_S386_taxonomy_clean.tsv,3706413",
  "18447511,11143_HD_META_Z4T3_S387_taxonomy_clean.tsv,2698497",
  "18804761,11143_HD_META_Z6T2_S388_taxonomy_clean.tsv,2731455",
  "22198252,11143_HD_META_Z6T3_S390_taxonomy_clean.tsv,3408959"
  )
) %>%
  separate(data, into = c("total.reads","Sample","classified.reads"), sep = ",") %>%
  mutate(Sample = str_remove(Sample, "11143_HD_META_") %>% 
                  str_remove("_S..._taxonomy_clean.tsv"),
         total.reads = as.integer(total.reads),
         unclassified.reads = (total.reads - as.integer(classified.reads)) / total.reads,
         classified.reads = as.integer(classified.reads) / total.reads)

classifications.boxplot <- classifications %>%
  select(Sample, classified.reads) %>%
  filter(Sample != "BF3") %>%
  separate_wider_position(Sample, c(Treatment.group = 1, replicate = 1, time = 2), too_few = "align_start") %>% 
  mutate(Treatment.group = if_else(
    Treatment.group == "L", "Standard DNA extraction", 
        if_else(Treatment.group == "N", "CpG-methylated",
            if_else(Treatment.group == "Z","Zymo", NA))),
    Treatment.group = factor(Treatment.group, levels = c("Standard DNA extraction", "CpG-methylated", "Zymo")))

classifications.median <- classifications.boxplot %>%
  group_by(Treatment.group) %>%
  summarise(median = round(median(classified.reads*100), digits = 1))

ggplot(classifications.boxplot,
       aes(x = Treatment.group, y = classified.reads*100)) +
  geom_boxplot(aes(fill = Treatment.group)) +
  geom_text(data = classifications.median,
            aes(x = Treatment.group, y = median, label = median),
            size = 5, vjust = 0.5) +
  geom_point(size = 3) +
  # geom_signif(data = filter(stat.table, p.adj <= 0.05), 
  #             aes(xmin = pair1, xmax = pair2, annotations = sig.star, 
  #                 y_position = 29), manual = T, size = 1) +
  scale_fill_manual(values = TG.clrs) +
  xlab("Treatment Group") +
  ylab("Reads classified as microbial (%)") +
  theme_bw()

```
